---
path: /blog/a-star-search/
type: post

title: A* সার্চ
subtitle: "স্লাইডিং পাজল সমাধান: ডিএফএস vs বিএফএস vs A*  সার্চ"
image: ./ast.png

date: 2019-05-07

tags:
  - algorithm
  - cp
  - puzzle

allowComments: true
---

import SlidingPuzzle from './SlidingPuzzle/SlidingPuzzle';

একটি স্লাইডিং পাজলে সাধারণত মোট আটটি স্কয়ার আর একটি খালি জায়গা থাকে। খালি জায়গাটির অবস্থান পরিবর্তন করে পাজলটিকে এলোমেলো করা যায়, আবার সমাধানও করা যায়। আমরা কোড করে এই পাজলটিকে সমাধন করার চেষ্টা করব।

খালি জয়গা সহ নয়টি স্কয়ারের মোট ৯! = ৩৬২৮৮০ রকম কনফিগারেশন হতে পারে। যার মধ্যে একটি কনফিগারেশন আমাদের সমাধান। আমাদের কাজ হবে  যেকোন এলোমেলো কনফিগারেশন থেকে সেই কনফিগারেশনে কিভাবে যেতে হবে বের করা।

আমরা সমস্যাটিকে একটি গ্রাফ হিসেবে বিবেচনা করব। যেখানে প্রতিটি কনফিগারেশন হল একেকটি নোড। আার ঐ কনফিগারেশন থেকে যে সব কনফিগারেশনে যাওয়া যায় সেগুলো হল ঐ নোডের নেইবার। প্রতিটি নোডকে আমরা ০ থেকে ৯ সংখ্যাগুলোর একটি অ্যারে দিয়ে রিপ্রেজেন্ট করব।

এখনে ব্যবহার করা অ্যালগরিদমগুলোর মূল প্রক্রিয়া একই। আমরা শুরুর এলমেলো নোডটি `toCheck` এ রাখব। আর যে নোডগুলো অলরেডি চেক করা হয়েছে সেগুলো রাখার জন্য `checked` একটি সেট নেব। তারপর `toCheck` থেকে একেকটি নোড নিয়ে চেক করতে থাকব। যদি দেখা যায় নোডটি আমাদের সমাধান নোড তহলে এই নোডে আসার স্টেপগুলোই আমাদের সমাধান। আর যদি না হয় তাহলে ঐ নোডের আশেপাশের নোডগুলো বের করে `toCheck` এ রাখব (যদি সেটা `checked` এ না থাকে) এবং `checked` এ চেক করা নোডটি রেখে দেব। যতক্ষণ না সমাধান পাওয়া যায় এভাবে চালিয়ে যাব।

### ডিএফএস

DFS এ আমরা `toCheck` এর জন্য একটি স্ট্যাক ব্যবহার করি।

```js
class Node {
  constructor(config, prev = null, move = null) {
    this.config = config;
    this.move = move;
    this.prev = prev;
  }

  solved() {...
  }
  neighbors() {...
  }
  getMoves() {...
  }
}

function dfs(node) {
  const toCheck = [node];
  const checked = new Set();

  while (toCheck.length > 0) {
    const currentNode = toCheck.pop();

    if (currentNode.solved()) {
      return currentNode.getMoves();
    }

    checked.add(currentNode.str);

    for (const node of currentNode.neighbors()) {
      if (!checked.has(node.str)) {
        toCheck.push(node);
      }
    }
  }
}
```

ট্রাই করুন: (অ্যারো কি ব্যাবহার করে এলোমেলো করতে পারেন)

<SlidingPuzzle methods={['dfs']} id="#1" />

কাজ চলে। শুধু ছ‌োট্ট একটি সমস্যা হল → → ↓ দিয়ে এলোমেলো করা হলে প্রায় এক লক্ষেরও বেশি স্টেপওয়ালা সমাধান বের হয়! যেখানে মাত্র তিন স্টেপেই সমাধান হওয়ার কথা।

এমনটা কেন হচ্ছে? কারণ DFS বা 'ডেপথ্ ফার্স্ট সার্চ' এর মানেই হল গ্রাফের সবচেয়ে গভীরে আগে খুঁজবে। ব্যাপারটা অনেকটা এমন হচ্ছে:

![dfs](./dfs.png)

### বিএফএস

তারপর আসা যাক BFS এ। আমরা জানি BFS একটি শর্টেস্ট পাথ অ্যালগরিদম। DFS এর সাথে এর পার্থক্য হল শুধু স্ট্যাকের বদলে কিউ ব্যবহার করতে হয়। এতে করে গ্রাফের গভীরে যাওয়ার আগে কাছের নোডগুলো আগে ভিজিট হয়। (জাভাস্ক্রিপ্টে স্ট্যাক, কিউ দুটোর কাজই অ্যারে দিয়ে চালানো যায়। `js।.pop()` করলে শেষের উপাদান পওয়া যায় আর `js।.shift()` করলে সামনের)

```js
function bfs(node) {
  const toCheck = [node];
  const visited = new Set();

  while (toCheck.length >= 0) {
    const currentNode = toCheck.shift();

    if (currentNode.solved()) {
      return currentNode.getMoves();
    }

    visited.add(currentNode.toString());

    for (const node of currentNode.neighbors()) {
      if (!visited.has(node.toString())) {
        toCheck.push(node);
      }
    }
  }
}
```

<SlidingPuzzle methods={['dfs', 'bfs']} id="#2" />

চমৎকার। তাই না? মনে হতে পারে BFS DFS কে পুরো শুইয়ে দিসে। তাহলে এই কনফিগারেশনটি ট্রাই করুন।

<SlidingPuzzle
  methods={['dfs', 'bfs']}
  givenState={[1, 0, 6, 8, 3, 4, 2, 7, 5]}
  id="#3"
/>

কি দেখলেন? DFS থেকে BFS মুটামুটি দশগুন বেশি সময় নেয়। কেন? কারণ BFS ফইনাল নোড যত গভীরে আছে সেই গভীরতা পর্যন্ত সকল নোড চেক করে। এজন্য কনফিগারেশনটি খুব বেশি এলোমেলো হলে আর্থাৎ সলিউশন নোড খুব দূরে হলে বিশাল সংখ্যক নোড চেক করতে হয়।এতে সময় যেমন বেশি লাগে আবার ভিজিটেট নোডগুলো হিসেব রাখতে মেমরিও বেশি লাগে।

![bfs](./bfs.png)

চিত্রে দেখতে পাচ্ছে সলিউশন নোডের দূরত্ব শুরুর নোড থেকে ৩। BFS এর ক্ষেত্রে তিন দূরত্বের সকল নোড চেক করতে হবে। বুঝতেই পারছেন দূরত্ব বাড়ার সাথে সাথে চেক করা নোডের সংখ্যা খুব দ্রুত বাড়বে।

### A\* সার্চ

এখানো দুটো অ্যাপ্রোচের সমস্যা মুটামুটি একই। কোন নোডগুলো আগে চেক করতে হবে ঠিক করতে না পারা। কাছেরগুলো আগে চেক করলে অনেকগুলো চেক করতে হয়। আর গভীরেরগুলো আগে চেক করলে বিশাল লম্বা সলিউশন বের হয়। কোন নোডগুলো আগে চেক করতে হবে সেটা যদি শুধু একটু বুদ্ধি করে ঠিক করা যেত!

নেইবরগুলো `toCheck` এ রাখার সময় আমরা সলিউশন নোড থেকে এর দূরত্ব হিসেব করতে পারি। আর স্ট্যাক কিংবা কিউ না ব্যবহার করে প্রায়োরিটি কিউ ব্যবহার করতে পারি, যাতে সবচেয়ে কম দূরত্বের নোডগুলো আগে আসে। Bingo!

<SlidingPuzzle
  methods={['dfs', 'bfs', 'ast']}
  givenState={[1, 0, 6, 8, 3, 4, 2, 7, 5]}
  id="#3"
/>
